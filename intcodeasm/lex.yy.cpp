// lex.yy.cpp generated by reflex 1.5.4 from intcodeasm.l

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_YYLTYPE             yy::location
#define REFLEX_OPTION_YYSTYPE             yy::parser::semantic_type
#define REFLEX_OPTION_bison_cc            true
#define REFLEX_OPTION_bison_cc_namespace  yy
#define REFLEX_OPTION_bison_cc_parser     parser
#define REFLEX_OPTION_bison_complete      true
#define REFLEX_OPTION_bison_locations     true
#define REFLEX_OPTION_case_insensitive    true
#define REFLEX_OPTION_exception           yy::parser::syntax_error(location(), "Unknown token.")
#define REFLEX_OPTION_fast                true
#define REFLEX_OPTION_freespace           true
#define REFLEX_OPTION_header_file         "lex.yy.h"
#define REFLEX_OPTION_lex                 lex
#define REFLEX_OPTION_lexer               Lexer
#define REFLEX_OPTION_namespace           yy
#define REFLEX_OPTION_outfile             "lex.yy.cpp"
#define REFLEX_OPTION_token_type          yy::parser::symbol_type

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top{ user code %}                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 1 "intcodeasm.l"

#include "intcodeasm.tab.hh"    /* Generated by bison. */
#include "location.hh"  /* Generated by bison %locations. */
#include "position.hh"  /* Generated by ?? */
#include "util.h"


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  ABSTRACT LEXER CLASS                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/abslexer.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace yy {

class Lexer : public reflex::AbstractLexer<reflex::Matcher> {
#line 14 "intcodeasm.l"

 protected:
	bool 	need_eol;

 public:
  typedef reflex::AbstractLexer<reflex::Matcher> AbstractBaseLexer;
  Lexer(
      const reflex::Input& input = reflex::Input(),
      std::ostream&        os    = std::cout)
    :
      AbstractBaseLexer(input, os)
  {
#line 19 "intcodeasm.l"

	need_eol = true;

  }
  static const int INITIAL = 0;
  static const int COMMENT = 1;
  virtual yy::location location(void) const
  {
    yy::location yylloc;
    yylloc.begin.line = static_cast<unsigned int>(matcher().lineno());
    yylloc.begin.column = static_cast<unsigned int>(matcher().columno());
    yylloc.end.line = static_cast<unsigned int>(matcher().lineno_end());
    yylloc.end.column = static_cast<unsigned int>(matcher().columno_end());
    return yylloc;
  }
  virtual yy::parser::symbol_type lex(void);
};

} // namespace yy

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %{ user code %}                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 23 "intcodeasm.l"
/* throw an exception in the scanner's default rule */
#line 28 "intcodeasm.l"


// test



////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  BISON C++                                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace yy {
extern void reflex_code_INITIAL(reflex::Matcher&);
} // namespace yy
namespace yy {
extern void reflex_code_COMMENT(reflex::Matcher&);
} // namespace yy

yy::parser::symbol_type yy::Lexer::lex()
{
  static const reflex::Pattern PATTERN_INITIAL(reflex_code_INITIAL);
  static const reflex::Pattern PATTERN_COMMENT(reflex_code_COMMENT);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
  }
  while (true)
  {
    switch (start())
    {
      case INITIAL:
        matcher().pattern(PATTERN_INITIAL);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return yy::parser::symbol_type();
            }
            else
            {
              throw yy::parser::syntax_error(location(), "Unknown token.");
            }
            break;
          case 1: // rule at line 47: (?:\r?\n)
#line 47 "intcodeasm.l"
{ return yy::parser::make_EOL(location()); }
            break;
          case 2: // rule at line 48: (?:[\x09\x20]+)
#line 48 "intcodeasm.l"
{ /* ignore */ }
            break;
          case 3: // rule at line 49: ;
#line 49 "intcodeasm.l"
{ start(COMMENT); }

            break;
          case 4: // rule at line 51: [Bb][Pp]
#line 51 "intcodeasm.l"
{ return yy::parser::make_KEYWORD_BP(location()); }

            break;
          case 5: // rule at line 53: [Aa][Dd][Dd]
          case 6: // rule at line 54: [Mm][Uu][Ll]
          case 7: // rule at line 55: [Ii][Nn][Pp]
          case 8: // rule at line 56: [Oo][Uu][Tt]
          case 9: // rule at line 57: [Jj][Nn][Zz]
          case 10: // rule at line 58: [Jj][Zz]
          case 11: // rule at line 59: [Cc][Mm][Pp][Ll][Tt]
          case 12: // rule at line 60: [Cc][Mm][Pp][Ee][Qq]
          case 13: // rule at line 61: [Aa][Bb][Pp]
          case 14: // rule at line 62: [Hh][Aa][Ll][Tt]
#line 62 "intcodeasm.l"
{ return yy::parser::make_MNEMONIC(str(), location()); }

            break;
          case 15: // rule at line 64: [Dd][Ii]
#line 64 "intcodeasm.l"
{ return yy::parser::make_KEYWORD_DI(location()); }


            break;
          case 16: // rule at line 67: (?:[A-Z_a-z][\x240-9A-Z_a-z]*)
#line 67 "intcodeasm.l"
{ return yy::parser::make_IDENTIFIER(str(), location()); }
            break;
          case 17: // rule at line 68: [()+-\x2d:\x5b\x5d]
#line 68 "intcodeasm.l"
{ return yy::parser::symbol_type(text()[0], location()); }
            break;
          case 18: // rule at line 69: (?:(?:0[xX][0-9A-Fa-f]+)|(?:[0-9]+))
#line 69 "intcodeasm.l"
{ return yy::parser::make_INTEGER(util::string_to_intmax(text(), 10), location()); }

            break;
          case 19: // rule at line 76: .
#line 76 "intcodeasm.l"
{ throw yy::parser::syntax_error(location(), "Unexpected character"); }

            break;
          case 20: // rule at line 78: <<[Ee][Oo][Ff]>>
#line 78 "intcodeasm.l"
{
	if (need_eol) { need_eol = false; return yy::parser::make_EOL(location()); }
	return yy::parser::symbol_type();
}

            break;
        }
        break;
      case COMMENT:
        matcher().pattern(PATTERN_COMMENT);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return yy::parser::symbol_type();
            }
            else
            {
              throw yy::parser::syntax_error(location(), "Unknown token.");
            }
            break;
          case 1: // rule at line 72: (?:\r?\n)
#line 72 "intcodeasm.l"
{ start(INITIAL); return yy::parser::make_EOL(location()); }
            break;
          case 2: // rule at line 73: [^\x0a]+
#line 73 "intcodeasm.l"
{ /* ignore */ }
            break;
          case 3: // rule at line 76: .
#line 76 "intcodeasm.l"
{ throw yy::parser::syntax_error(location(), "Unexpected character"); }

            break;
        }
        break;
      default:
        start(0);
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  TABLES                                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

#if defined(OS_WIN)
#pragma warning(disable:4101 4102)
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-label"
#elif defined(__clang__)
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-label"
#endif

namespace yy {

void reflex_code_INITIAL(reflex::Matcher& m)
{
  int c0 = 0, c1 = 0;
  m.FSM_INIT(c1);

S0:
  m.FSM_FIND();
  c1 = m.FSM_CHAR();
  if (c1 == 'o') goto S77;
  if (c1 == 'm') goto S59;
  if (c1 == 'j') goto S86;
  if (c1 == 'i') goto S68;
  if (c1 == 'h') goto S106;
  if ('e' <= c1 && c1 <= 'z') goto S124;
  if (c1 == 'd') goto S115;
  if (c1 == 'c') goto S97;
  if (c1 == 'b') goto S39;
  if (c1 == 'a') goto S48;
  if (c1 == '_') goto S124;
  if (c1 == ']') goto S131;
  if (c1 == '[') goto S131;
  if (c1 == 'O') goto S77;
  if (c1 == 'M') goto S59;
  if (c1 == 'J') goto S86;
  if (c1 == 'I') goto S68;
  if (c1 == 'H') goto S106;
  if ('E' <= c1 && c1 <= 'Z') goto S124;
  if (c1 == 'D') goto S115;
  if (c1 == 'C') goto S97;
  if (c1 == 'B') goto S39;
  if (c1 == 'A') goto S48;
  if (c1 == '<') goto S140;
  if (c1 == ';') goto S37;
  if (c1 == ':') goto S131;
  if ('1' <= c1 && c1 <= '9') goto S150;
  if (c1 == '0') goto S133;
  if ('+' <= c1 && c1 <= '-') goto S131;
  if ('(' <= c1 && c1 <= ')') goto S131;
  if (c1 == ' ') goto S146;
  if (c1 == '\r') goto S143;
  if (c1 == '\n') goto S35;
  if (c1 == '\t') goto S146;
  if (0 <= c1) goto S138;
  return m.FSM_HALT(c1);

S35:
  m.FSM_TAKE(1);
  return m.FSM_HALT();

S37:
  m.FSM_TAKE(3);
  return m.FSM_HALT();

S39:
  m.FSM_TAKE(16);
  c1 = m.FSM_CHAR();
  if (c1 == 'p') goto S153;
  if ('a' <= c1 && c1 <= 'z') goto S124;
  if (c1 == '_') goto S124;
  if (c1 == 'P') goto S153;
  if ('A' <= c1 && c1 <= 'Z') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S48:
  m.FSM_TAKE(16);
  c1 = m.FSM_CHAR();
  if (c1 == 'd') goto S160;
  if (c1 == 'b') goto S169;
  if ('a' <= c1 && c1 <= 'z') goto S124;
  if (c1 == '_') goto S124;
  if (c1 == 'D') goto S160;
  if (c1 == 'B') goto S169;
  if ('A' <= c1 && c1 <= 'Z') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S59:
  m.FSM_TAKE(16);
  c1 = m.FSM_CHAR();
  if (c1 == 'u') goto S178;
  if ('a' <= c1 && c1 <= 'z') goto S124;
  if (c1 == '_') goto S124;
  if (c1 == 'U') goto S178;
  if ('A' <= c1 && c1 <= 'Z') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S68:
  m.FSM_TAKE(16);
  c1 = m.FSM_CHAR();
  if (c1 == 'n') goto S187;
  if ('a' <= c1 && c1 <= 'z') goto S124;
  if (c1 == '_') goto S124;
  if (c1 == 'N') goto S187;
  if ('A' <= c1 && c1 <= 'Z') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S77:
  m.FSM_TAKE(16);
  c1 = m.FSM_CHAR();
  if (c1 == 'u') goto S196;
  if ('a' <= c1 && c1 <= 'z') goto S124;
  if (c1 == '_') goto S124;
  if (c1 == 'U') goto S196;
  if ('A' <= c1 && c1 <= 'Z') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S86:
  m.FSM_TAKE(16);
  c1 = m.FSM_CHAR();
  if (c1 == 'z') goto S214;
  if (c1 == 'n') goto S205;
  if ('a' <= c1 && c1 <= 'y') goto S124;
  if (c1 == '_') goto S124;
  if (c1 == 'Z') goto S214;
  if (c1 == 'N') goto S205;
  if ('A' <= c1 && c1 <= 'Y') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S97:
  m.FSM_TAKE(16);
  c1 = m.FSM_CHAR();
  if (c1 == 'm') goto S221;
  if ('a' <= c1 && c1 <= 'z') goto S124;
  if (c1 == '_') goto S124;
  if (c1 == 'M') goto S221;
  if ('A' <= c1 && c1 <= 'Z') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S106:
  m.FSM_TAKE(16);
  c1 = m.FSM_CHAR();
  if ('b' <= c1 && c1 <= 'z') goto S124;
  if (c1 == 'a') goto S230;
  if (c1 == '_') goto S124;
  if ('B' <= c1 && c1 <= 'Z') goto S124;
  if (c1 == 'A') goto S230;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S115:
  m.FSM_TAKE(16);
  c1 = m.FSM_CHAR();
  if (c1 == 'i') goto S239;
  if ('a' <= c1 && c1 <= 'z') goto S124;
  if (c1 == '_') goto S124;
  if (c1 == 'I') goto S239;
  if ('A' <= c1 && c1 <= 'Z') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S124:
  m.FSM_TAKE(16);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S124;
  if (c1 == '_') goto S124;
  if ('A' <= c1 && c1 <= 'Z') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S131:
  m.FSM_TAKE(17);
  return m.FSM_HALT();

S133:
  m.FSM_TAKE(18);
  c1 = m.FSM_CHAR();
  if (c1 == 'x') goto S246;
  if (c1 == 'X') goto S246;
  if ('0' <= c1 && c1 <= '9') goto S150;
  return m.FSM_HALT(c1);

S138:
  m.FSM_TAKE(19);
  return m.FSM_HALT();

S140:
  m.FSM_TAKE(19);
  c1 = m.FSM_CHAR();
  if (c1 == '<') goto S250;
  return m.FSM_HALT(c1);

S143:
  m.FSM_TAKE(19);
  c1 = m.FSM_CHAR();
  if (c1 == '\n') goto S35;
  return m.FSM_HALT(c1);

S146:
  m.FSM_TAKE(2);
  c1 = m.FSM_CHAR();
  if (c1 == ' ') goto S146;
  if (c1 == '\t') goto S146;
  return m.FSM_HALT(c1);

S150:
  m.FSM_TAKE(18);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S150;
  return m.FSM_HALT(c1);

S153:
  m.FSM_TAKE(4);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S124;
  if (c1 == '_') goto S124;
  if ('A' <= c1 && c1 <= 'Z') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S160:
  m.FSM_TAKE(16);
  c1 = m.FSM_CHAR();
  if (c1 == 'd') goto S253;
  if ('a' <= c1 && c1 <= 'z') goto S124;
  if (c1 == '_') goto S124;
  if (c1 == 'D') goto S253;
  if ('A' <= c1 && c1 <= 'Z') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S169:
  m.FSM_TAKE(16);
  c1 = m.FSM_CHAR();
  if (c1 == 'p') goto S260;
  if ('a' <= c1 && c1 <= 'z') goto S124;
  if (c1 == '_') goto S124;
  if (c1 == 'P') goto S260;
  if ('A' <= c1 && c1 <= 'Z') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S178:
  m.FSM_TAKE(16);
  c1 = m.FSM_CHAR();
  if (c1 == 'l') goto S267;
  if ('a' <= c1 && c1 <= 'z') goto S124;
  if (c1 == '_') goto S124;
  if (c1 == 'L') goto S267;
  if ('A' <= c1 && c1 <= 'Z') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S187:
  m.FSM_TAKE(16);
  c1 = m.FSM_CHAR();
  if (c1 == 'p') goto S274;
  if ('a' <= c1 && c1 <= 'z') goto S124;
  if (c1 == '_') goto S124;
  if (c1 == 'P') goto S274;
  if ('A' <= c1 && c1 <= 'Z') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S196:
  m.FSM_TAKE(16);
  c1 = m.FSM_CHAR();
  if (c1 == 't') goto S281;
  if ('a' <= c1 && c1 <= 'z') goto S124;
  if (c1 == '_') goto S124;
  if (c1 == 'T') goto S281;
  if ('A' <= c1 && c1 <= 'Z') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S205:
  m.FSM_TAKE(16);
  c1 = m.FSM_CHAR();
  if (c1 == 'z') goto S288;
  if ('a' <= c1 && c1 <= 'y') goto S124;
  if (c1 == '_') goto S124;
  if (c1 == 'Z') goto S288;
  if ('A' <= c1 && c1 <= 'Y') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S214:
  m.FSM_TAKE(10);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S124;
  if (c1 == '_') goto S124;
  if ('A' <= c1 && c1 <= 'Z') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S221:
  m.FSM_TAKE(16);
  c1 = m.FSM_CHAR();
  if (c1 == 'p') goto S295;
  if ('a' <= c1 && c1 <= 'z') goto S124;
  if (c1 == '_') goto S124;
  if (c1 == 'P') goto S295;
  if ('A' <= c1 && c1 <= 'Z') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S230:
  m.FSM_TAKE(16);
  c1 = m.FSM_CHAR();
  if (c1 == 'l') goto S306;
  if ('a' <= c1 && c1 <= 'z') goto S124;
  if (c1 == '_') goto S124;
  if (c1 == 'L') goto S306;
  if ('A' <= c1 && c1 <= 'Z') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S239:
  m.FSM_TAKE(15);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S124;
  if (c1 == '_') goto S124;
  if ('A' <= c1 && c1 <= 'Z') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S246:
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'f') goto S315;
  if ('A' <= c1 && c1 <= 'F') goto S315;
  if ('0' <= c1 && c1 <= '9') goto S315;
  return m.FSM_HALT(c1);

S250:
  c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S320;
  if (c1 == 'E') goto S320;
  return m.FSM_HALT(c1);

S253:
  m.FSM_TAKE(5);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S124;
  if (c1 == '_') goto S124;
  if ('A' <= c1 && c1 <= 'Z') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S260:
  m.FSM_TAKE(13);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S124;
  if (c1 == '_') goto S124;
  if ('A' <= c1 && c1 <= 'Z') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S267:
  m.FSM_TAKE(6);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S124;
  if (c1 == '_') goto S124;
  if ('A' <= c1 && c1 <= 'Z') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S274:
  m.FSM_TAKE(7);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S124;
  if (c1 == '_') goto S124;
  if ('A' <= c1 && c1 <= 'Z') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S281:
  m.FSM_TAKE(8);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S124;
  if (c1 == '_') goto S124;
  if ('A' <= c1 && c1 <= 'Z') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S288:
  m.FSM_TAKE(9);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S124;
  if (c1 == '_') goto S124;
  if ('A' <= c1 && c1 <= 'Z') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S295:
  m.FSM_TAKE(16);
  c1 = m.FSM_CHAR();
  if (c1 == 'l') goto S323;
  if (c1 == 'e') goto S332;
  if ('a' <= c1 && c1 <= 'z') goto S124;
  if (c1 == '_') goto S124;
  if (c1 == 'L') goto S323;
  if (c1 == 'E') goto S332;
  if ('A' <= c1 && c1 <= 'Z') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S306:
  m.FSM_TAKE(16);
  c1 = m.FSM_CHAR();
  if (c1 == 't') goto S341;
  if ('a' <= c1 && c1 <= 'z') goto S124;
  if (c1 == '_') goto S124;
  if (c1 == 'T') goto S341;
  if ('A' <= c1 && c1 <= 'Z') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S315:
  m.FSM_TAKE(18);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'f') goto S315;
  if ('A' <= c1 && c1 <= 'F') goto S315;
  if ('0' <= c1 && c1 <= '9') goto S315;
  return m.FSM_HALT(c1);

S320:
  c1 = m.FSM_CHAR();
  if (c1 == 'o') goto S348;
  if (c1 == 'O') goto S348;
  return m.FSM_HALT(c1);

S323:
  m.FSM_TAKE(16);
  c1 = m.FSM_CHAR();
  if (c1 == 't') goto S351;
  if ('a' <= c1 && c1 <= 'z') goto S124;
  if (c1 == '_') goto S124;
  if (c1 == 'T') goto S351;
  if ('A' <= c1 && c1 <= 'Z') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S332:
  m.FSM_TAKE(16);
  c1 = m.FSM_CHAR();
  if (c1 == 'q') goto S358;
  if ('a' <= c1 && c1 <= 'z') goto S124;
  if (c1 == '_') goto S124;
  if (c1 == 'Q') goto S358;
  if ('A' <= c1 && c1 <= 'Z') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S341:
  m.FSM_TAKE(14);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S124;
  if (c1 == '_') goto S124;
  if ('A' <= c1 && c1 <= 'Z') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S348:
  c1 = m.FSM_CHAR();
  if (c1 == 'f') goto S365;
  if (c1 == 'F') goto S365;
  return m.FSM_HALT(c1);

S351:
  m.FSM_TAKE(11);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S124;
  if (c1 == '_') goto S124;
  if ('A' <= c1 && c1 <= 'Z') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S358:
  m.FSM_TAKE(12);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S124;
  if (c1 == '_') goto S124;
  if ('A' <= c1 && c1 <= 'Z') goto S124;
  if ('0' <= c1 && c1 <= '9') goto S124;
  if (c1 == '$') goto S124;
  return m.FSM_HALT(c1);

S365:
  c1 = m.FSM_CHAR();
  if (c1 == '>') goto S367;
  return m.FSM_HALT(c1);

S367:
  c1 = m.FSM_CHAR();
  if (c1 == '>') goto S369;
  return m.FSM_HALT(c1);

S369:
  m.FSM_TAKE(20);
  return m.FSM_HALT();
}

} // namespace yy

#include <reflex/matcher.h>

#if defined(OS_WIN)
#pragma warning(disable:4101 4102)
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-label"
#elif defined(__clang__)
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-label"
#endif

namespace yy {

void reflex_code_COMMENT(reflex::Matcher& m)
{
  int c0 = 0, c1 = 0;
  m.FSM_INIT(c1);

S0:
  m.FSM_FIND();
  c1 = m.FSM_CHAR();
  if (c1 == '\r') goto S9;
  if (c1 == '\n') goto S3;
  if (0 <= c1) goto S5;
  return m.FSM_HALT(c1);

S3:
  m.FSM_TAKE(1);
  return m.FSM_HALT();

S5:
  m.FSM_TAKE(2);
  c1 = m.FSM_CHAR();
  if ('\v' <= c1) goto S5;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\t') goto S5;
  return m.FSM_HALT(c1);

S9:
  m.FSM_TAKE(2);
  c1 = m.FSM_CHAR();
  if (c1 == '\n') goto S3;
  if (0 <= c1) goto S5;
  return m.FSM_HALT(c1);
}

} // namespace yy

