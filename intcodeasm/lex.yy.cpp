// lex.yy.cpp generated by reflex 1.5.4 from intcodeasm.l

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define REFLEX_OPTION_case_insensitive    true
#define REFLEX_OPTION_fast                true
#define REFLEX_OPTION_freespace           true
#define REFLEX_OPTION_header_file         "lex.yy.h"
#define REFLEX_OPTION_lex                 lex
#define REFLEX_OPTION_lexer               Lexer
#define REFLEX_OPTION_outfile             "lex.yy.cpp"

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top{ user code %}                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 1 "intcodeasm.l"


#include "../lexer-test/symbols.h"



////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  ABSTRACT LEXER CLASS                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/abslexer.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

class Lexer : public reflex::AbstractLexer<reflex::Matcher> {
 public:
  typedef reflex::AbstractLexer<reflex::Matcher> AbstractBaseLexer;
  Lexer(
      const reflex::Input& input = reflex::Input(),
      std::ostream&        os    = std::cout)
    :
      AbstractBaseLexer(input, os)
  {
  }
  static const int INITIAL = 0;
  static const int COMMENT = 1;
  virtual int lex();
  int lex(
      const reflex::Input& input,
      std::ostream        *os = NULL)
  {
    in(input);
    if (os)
      out(*os);
    return lex();
  }
};

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

extern void reflex_code_INITIAL(reflex::Matcher&);
extern void reflex_code_COMMENT(reflex::Matcher&);

int Lexer::lex()
{
  static const reflex::Pattern PATTERN_INITIAL(reflex_code_INITIAL);
  static const reflex::Pattern PATTERN_COMMENT(reflex_code_COMMENT);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
  }
  while (true)
  {
    switch (start())
    {
      case INITIAL:
        matcher().pattern(PATTERN_INITIAL);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return int();
            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule at line 18: (?:\r?\n)
#line 18 "intcodeasm.l"
{ return '\n'; }
            break;
          case 2: // rule at line 19: (?:[\x09\x20]+)
#line 19 "intcodeasm.l"
{ /* ignore */ }
            break;
          case 3: // rule at line 20: ;
#line 20 "intcodeasm.l"
{ start(COMMENT); }
            break;
          case 4: // rule at line 21: (?:[A-Z_a-z][\x240-9A-Z_a-z]*)
#line 21 "intcodeasm.l"
{ return WORD; }
            break;
          case 5: // rule at line 22: [()+-\x2d:\x5b\x5d]
#line 22 "intcodeasm.l"
{ return text()[0]; }
            break;
          case 6: // rule at line 23: (?:(?:0[xX][0-9A-Fa-f]+)|(?:[0-9]+))
#line 23 "intcodeasm.l"
{ return INTEGER; }


            break;
          case 7: // rule at line 30: .
#line 30 "intcodeasm.l"
{ return ERR; }


            break;
        }
        break;
      case COMMENT:
        matcher().pattern(PATTERN_COMMENT);
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return int();
            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule at line 26: (?:\r?\n)
#line 26 "intcodeasm.l"
{ start(INITIAL); return EOL; }
            break;
          case 2: // rule at line 27: [^\x0a]+
#line 27 "intcodeasm.l"
{ /* ignore */ }
            break;
          case 3: // rule at line 30: .
#line 30 "intcodeasm.l"
{ return ERR; }


            break;
        }
        break;
      default:
        start(0);
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  TABLES                                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

#if defined(OS_WIN)
#pragma warning(disable:4101 4102)
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-label"
#elif defined(__clang__)
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-label"
#endif

void reflex_code_INITIAL(reflex::Matcher& m)
{
  int c0 = 0, c1 = 0;
  m.FSM_INIT(c1);

S0:
  m.FSM_FIND();
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S20;
  if (c1 == '_') goto S20;
  if (c1 == ']') goto S27;
  if (c1 == '[') goto S27;
  if ('A' <= c1 && c1 <= 'Z') goto S20;
  if (c1 == ';') goto S18;
  if (c1 == ':') goto S27;
  if ('1' <= c1 && c1 <= '9') goto S43;
  if (c1 == '0') goto S29;
  if ('+' <= c1 && c1 <= '-') goto S27;
  if ('(' <= c1 && c1 <= ')') goto S27;
  if (c1 == ' ') goto S39;
  if (c1 == '\r') goto S36;
  if (c1 == '\n') goto S16;
  if (c1 == '\t') goto S39;
  if (0 <= c1) goto S34;
  return m.FSM_HALT(c1);

S16:
  m.FSM_TAKE(1);
  return m.FSM_HALT();

S18:
  m.FSM_TAKE(3);
  return m.FSM_HALT();

S20:
  m.FSM_TAKE(4);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S20;
  if (c1 == '_') goto S20;
  if ('A' <= c1 && c1 <= 'Z') goto S20;
  if ('0' <= c1 && c1 <= '9') goto S20;
  if (c1 == '$') goto S20;
  return m.FSM_HALT(c1);

S27:
  m.FSM_TAKE(5);
  return m.FSM_HALT();

S29:
  m.FSM_TAKE(6);
  c1 = m.FSM_CHAR();
  if (c1 == 'x') goto S46;
  if (c1 == 'X') goto S46;
  if ('0' <= c1 && c1 <= '9') goto S43;
  return m.FSM_HALT(c1);

S34:
  m.FSM_TAKE(7);
  return m.FSM_HALT();

S36:
  m.FSM_TAKE(7);
  c1 = m.FSM_CHAR();
  if (c1 == '\n') goto S16;
  return m.FSM_HALT(c1);

S39:
  m.FSM_TAKE(2);
  c1 = m.FSM_CHAR();
  if (c1 == ' ') goto S39;
  if (c1 == '\t') goto S39;
  return m.FSM_HALT(c1);

S43:
  m.FSM_TAKE(6);
  c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S43;
  return m.FSM_HALT(c1);

S46:
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'f') goto S50;
  if ('A' <= c1 && c1 <= 'F') goto S50;
  if ('0' <= c1 && c1 <= '9') goto S50;
  return m.FSM_HALT(c1);

S50:
  m.FSM_TAKE(6);
  c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'f') goto S50;
  if ('A' <= c1 && c1 <= 'F') goto S50;
  if ('0' <= c1 && c1 <= '9') goto S50;
  return m.FSM_HALT(c1);
}

#include <reflex/matcher.h>

#if defined(OS_WIN)
#pragma warning(disable:4101 4102)
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-label"
#elif defined(__clang__)
#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wunused-label"
#endif

void reflex_code_COMMENT(reflex::Matcher& m)
{
  int c0 = 0, c1 = 0;
  m.FSM_INIT(c1);

S0:
  m.FSM_FIND();
  c1 = m.FSM_CHAR();
  if (c1 == '\r') goto S9;
  if (c1 == '\n') goto S3;
  if (0 <= c1) goto S5;
  return m.FSM_HALT(c1);

S3:
  m.FSM_TAKE(1);
  return m.FSM_HALT();

S5:
  m.FSM_TAKE(2);
  c1 = m.FSM_CHAR();
  if ('\v' <= c1) goto S5;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if (0 <= c1 && c1 <= '\t') goto S5;
  return m.FSM_HALT(c1);

S9:
  m.FSM_TAKE(2);
  c1 = m.FSM_CHAR();
  if (c1 == '\n') goto S3;
  if (0 <= c1) goto S5;
  return m.FSM_HALT(c1);
}

